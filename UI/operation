from typing import List
from fastapi import FastAPI, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import sessionmaker
from models import TodoModel, TagModel  # モデル定義を含むファイル
from schemas import TodoCreate, TodoResponse, TagCreate, TagResponse  # Pydanticスキーマ

# async_sessionは、SQLAlchemyのAsyncSessionを作成するためのsessionmakerのインスタンスと仮定
async_session = sessionmaker(bind=your_async_engine, class_=AsyncSession, expire_on_commit=False)

app = FastAPI()

# Todo一覧取得
@app.get("/todos", response_model=List[TodoResponse])
async def get_todos():
    async with async_session() as session:
        result = await session.execute(select(TodoModel))
        todos = result.scalars().all()
        return todos

# Todo作成
@app.post("/todos", response_model=TodoResponse)
async def create_todo(todo: TodoCreate):
    new_todo = TodoModel(title=todo.title)
    async with async_session() as session:
        session.add(new_todo)
        await session.commit()
        await session.refresh(new_todo)
        return new_todo

# Todo完了の更新
@app.put("/todos/{id}", response_model=TodoResponse)
async def update_todo_status(id: int):
    async with async_session() as session:
        result = await session.execute(select(TodoModel).where(TodoModel.Todonumber == id))
        todo = result.scalar_one_or_none()
        if not todo:
            raise HTTPException(status_code=404, detail="Todo not found")
        todo.done_tasks = True
        await session.commit()
        return todo

# Todo削除
@app.delete("/todos/{id}")
async def delete_todo(id: int):
    async with async_session() as session:
        result = await session.execute(select(TodoModel).where(TodoModel.Todonumber == id))
        todo = result.scalar_one_or_none()
        if not todo:
            raise HTTPException(status_code=404, detail="Todo not found")
        await session.delete(todo)
        await session.commit()
        return {"message": "Todo deleted"}

# タグ一覧取得
@app.get("/tags", response_model=List[TagResponse])
async def get_tags():
    async with async_session() as session:
        result = await session.execute(select(TagModel))
        tags = result.scalars().all()
        return tags

# タグ作成
@app.post("/tags", response_model=TagResponse)
async def create_tag(tag: TagCreate):
    new_tag = TagModel(outline=tag.outline)
    async with async_session() as session:
        session.add(new_tag)
        await session.commit()
        await session.refresh(new_tag)
        return new_tag